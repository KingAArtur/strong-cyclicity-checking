\section{Разработка модифицированного алгоритма}

На базе описанного метода был реализован модифицированный алгоритм, использующий рекурсию.
В отличие от предыдущего алгоритма, который выбирает для продолжения лишь один элемент матрицы,
модифицированный алгоритм будет перебирать все возможные элементы для продолжения.

Вход алгоритма:
\begin{itemize}
    \item
        квадратная матрица $A$ размера $m \times m$ с полиномиальными коэффициентами
    \item
        циклический вектор $v$
    \item
        максимальная степень элементов матрицы $degree$
    \item
        максимальная глубина рекурсии $depth$
\end{itemize}

Выход алгоритма "--- один из следующих ответов:
\begin{itemize}
    \item
        ответ <<не сильно циклический>> + продолжение, опровергающее сильную цикличность
    \item
        ответ <<сильно циклический>>
    \item
        ответ <<неизвестно>>
\end{itemize}

Шаги алгоритма:
\begin{enumerate}
    \item
        Если $depth = 0$, вернуть ответ <<неизвестно>>.
    \item
        Положить $solutions = $ пустой список.
        Этот список будет содержать тройки вида $(i, j, sol)$,
        где $i, j$ "--- номера элементов матрицы, $sol$ "--- некоторый числовой коэффициент,
        которым следует продолжить данный элемент.
    \item
        Перебираем все элементы матрицы с номерами $(i, j)$ в некотором порядке (например, сначала по строкам, затем по столбцам):
        \begin{enumerate}
            \item
                Копируем матрицу $A$ в матрицу $B$: $B = Copy(A)$;
            \item
                Продолжаем текущий элемент матрицы слагаемым с символьным коэффициентом $c$:
                $B_{ij} += cx^{degree + 1}$;
            \item
                Находим $det(c, x)$ "--- определитель матрицы \diffMatrix[B] как многочлен от $x$,
                коэффициенты которого "--- многочлены от $c$;
            \item
                Находим все ненулевые значения $c$, зануляющие $\tc det(c, x)$;
            \item
                Добавляем все найденные значения $c$ в список $solutions$ как тройки $(i, j, sol)$.
        \end{enumerate}
    \item
        Перебираем все тройки $(i, j, sol)$ из списка $solutions$:
        \begin{enumerate}
            \item
                Копируем матрицу $A$ в матрицу $B$: $B = Copy(A)$;
            \item
                Продолжаем элемент матрицы $(i, j)$ слагаемым с числовым коэффициентом $sol$:
                $B_{ij} += sol \cdot x^{degree + 1}$;
            \item
                \textbf{Рекурсивно} применяем данный алгоритм
                к матрице $B$, вектору $v$, степени $degree + 1$ и глубине рекурсии $depth - 1$;
            \item
                Если был получен ответ <<не сильно циклический>> + продолжение, вернуть данный ответ и продолжение.
        \end{enumerate}
    \item
        Если на предыдущем шаге хотя бы в одном случае был получен ответ <<неизвестно>>, вернуть ответ <<неизвестно>>.
    \item
        Вернуть ответ <<сильно циклический>>.
\end{enumerate}

Данный алгоритм всегда завершается благодаря ограниченной глубине рекурсии,
но он все еще не всегда может дать содержательный ответ.
Однако, такие ситуации должны быть более редкими, поскольку перебираются все элементы матрицы для продолжения,
и в случае захода в тупик будет производиться возврат и выбор следующего варианта.

[TODO тут картинка про объяснение рекурсии]
