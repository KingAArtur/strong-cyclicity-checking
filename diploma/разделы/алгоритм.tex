\section{Разработка алгоритма проверки\\ сильной цикличности вектора}

На~базе описанного метода был реализован модифицированный частичный алгоритм, использующий рекурсию.
Алгоритм получил название~\emph{SCC}
(\emph{Strong Cyclicity Check\-ing}).
В отличие от~метода~SMP, который выбирает для~продолжения лишь один элемент матрицы,
модифицированный алгоритм будет перебирать все возможные элементы для~продолжения.
\medskip

Вход алгоритма:
\begin{itemize}
    \item
        квадратная матрица~$A$ размера $m \times m$ с~полиномиальными коэффициентами;
    \item
        циклический вектор~$v$;
    \item
        максимальная глубина рекурсии~$depth$.
\end{itemize}

Выход алгоритма "--- один из~следующих ответов:
\begin{itemize}
    \item
        <<не сильно циклический>> + продолжение, опровергающее сильную цикличность;
    \item
        <<сильно циклический>>;
    \item
        <<неизвестно>>.
\end{itemize}

Шаги алгоритма:
\begin{enumerate}
    \item
        Если $depth = 0$, вернуть ответ~<<неизвестно>>.
    \item
        Положить $solutions = $ пустой список.
        Этот список будет содержать тройки вида~$(i, j, sol)$,
        где $i, j$ "--- номера элементов матрицы, $sol$ "--- некоторый числовой коэффициент,
        которым следует продолжить данный элемент.
    \item
        Перебираем все элементы матрицы с~номерами~$(i, j)$ в некотором порядке (например, сначала по~строкам, затем по~столбцам):
        \begin{enumerate}
            \item
                Копируем матрицу~$A$ в матрицу~$B$: $B = Copy(A)$;
            \item
                Определяем степень текущего элемента~$B_{ij}$ как многочлена от~$x$:
                $t = degree(B_{ij})$;
            \item
                Продолжаем текущий элемент матрицы слагаемым с~символьным коэффициентом~$c$:
                $B_{ij} \mathrel{{+}{=}} cx^{t + 1}$;
            \item
                Находим $det(c, x)$ "--- определитель матрицы \diffMatrix[B] как многочлен от~$x$,
                коэффициенты которого "--- многочлены от~$c$;
            \item
                Находим все ненулевые значения~$c$, зануляющие~$\tc(det(c, x))$;
                \begin{enumerate}
                    \item
                        Если какое-то значение~$c$ зануляет весь~$det(c, x)$,
                        то мы нашли опровергающее продолжение.
                        Подставляем в~матрицу~$B$ данное числовое значение вместо символа~$c$,
                        возвращаем ответ~<<не сильно циклический>> и матрицу~$B$ в~качестве опровергающего продолжения.
                \end{enumerate}
            \item
                Добавляем все найденные значения~$c$ в~список $solutions$ как тройки~$(i, j, sol)$.
        \end{enumerate}
    \item
        Перебираем все тройки $(i, j, sol)$ из~списка $solutions$:
        \begin{enumerate}
            \item
                Копируем матрицу~$A$ в матрицу~$B$: $B = Copy(A)$;
            \item
                Продолжаем элемент матрицы $(i, j)$ слагаемым с~числовым коэффициентом $sol$:
                $B_{ij} \mathrel{{+}{=}} sol \cdot x^{degree + 1}$;
            \item
                \textbf{Рекурсивно} применяем данный алгоритм
                к~матрице~$B$, вектору~$v$ и глубине рекурсии~$depth - 1$;
            \item
                Если был получен ответ~<<не сильно циклический>> + продолжение, вернуть данный ответ и продолжение
                и завершить работу алгоритма.
        \end{enumerate}
    \item
        Если на предыдущем шаге хотя бы в одном случае был получен ответ~<<неизвестно>>, вернуть ответ~<<неизвестно>>.
    \item
        Вернуть ответ~<<сильно циклический>>.
\end{enumerate}

Данный алгоритм всегда завершается благодаря ограниченной глубине рекурсии,
но он также не~всегда может дать содержательный ответ.
Однако, такие ситуации должны быть более редкими, поскольку перебираются все элементы матрицы для~продолжения,
и в~случае захода в~тупик производится возврат и выбор следующего варианта.
\medskip

Возможный ход работы алгоритма представлен на рис. 7.1:

\begin{center}
    \includegraphics[scale=0.6]{pictures/recursion.png}

    \small
    Рис. 7.1. Ход работы алгоритма
\end{center}

Пусть на вход алгоритму поступили матрица размера~$2 \times 2$ и некоторый вектор~$v$.
\newpage

\begin{enumerate}
    \item
        Изначально мы находимся в~вершине~1.
        Здесь есть три варианта построить одноэлементное продолжение:
        можно продолжить левый верхний элемент матрицы~($a_{11}$) "--- вершина~2,
        правый верхний~($a_{12}$) "--- вершина~3 и правый нижний ($a_{22}$) "--- вершина~7.
        Предполагаем, что для четвертого элемента~$a_{21}$ не нашлось способа продолжить продолжение так,
        чтобы занулить~$\tc(det(c, x))$.
        По~очереди рекурсивно вызываем процедуру для~указанных вариантов.
    \item
        Продолжили $a_{11}$, попали в~вершину~2. Отсюда невозможно продолжить построение опровергающего продолжения,
        возвращаем на предыдущий уровень~(1) предварительный ответ~<<сильно циклический>> и рассматриваем следующий вариант.
    \item
        Продолжили $a_{12}$, попали в~вершину~3. Здесь есть два способа построить одноэлементное продолжение новой матрицы,
        которые приведут нас в~вершины~4~и~5.
        По~очереди рекурсивно вызываем процедуру от~указанных вариантов.
    \item
        Попали в~вершину~4. Отсюда невозможно продолжить построение опровергающего продолжения,
        возвращаемся на предыдущий уровень~(3) с~предварительным ответом~<<сильно циклический>> и рассматриваем следующий вариант.
    \item
        Попали в~вершину~5. Здесь есть единственный вариант для~построения продолжения,
        отсюда мы попадем в~вершину~6.
    \item
        Попали в~вершину~6. Здесь оказывается, что была достигнута максимально допустимая глубина рекурсии.
        Возвращаем на~предыдущий уровень~(5) ответ~<<неизвестно>>,
        оттуда, в~свою~очередь, также вернется ответ~<<неизвестно>> на~предыдущий уровень~(3),
        а оттуда, аналогично, этот предварительный ответ попадет на~самый верхний уровень~(1).
    \item
        Продолжили $a_{22}$, попали в~вершину~7. Здесь есть единственный вариант для~построения продолжения,
        отсюда мы попадем в~вершину~8.
    \item
        Попали в~вершину~8. Здесь есть единственный вариант для~построения продолжения,
        причем это продолжение является опровергающим (определитель равен нулю).
        Возвращаем ответ~<<не сильно циклический>> и построенное продолжение,
        этот ответ и будет финальным результатом алгоритма.
\end{enumerate}

Стоит отметить, что алгоритм не~всегда может дать содержательный ответ.
Например, если~бы в~вершине~8 не~удалось получить опровергающее продолжение,
то пришлось~бы вернуть ответ~<<неизвестно>>,
поскольку в~вершине~6 мы уперлись в~максимально допустимую глубину рекурсии.

Выполнение алгоритма можно ускорить с помощью доказанного Предложения 3:
после шага 1 можно произвести проверку неравенства из указанного предложения,
это позволит в некоторых случаях избавиться от перебора элементов матрицы и сразу получить ответ.
